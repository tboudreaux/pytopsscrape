from pyTOPSScrape.ext import numfrac
from pyTOPSScrape.parse.abundance import open_and_parse

from io import BinaryIO
import numpy as np
import re
from tqdm import tqdm

from tempfile import TemporaryFile

from typing import Tuple, Union

def parse_numfrac_file(
        file: BinaryIO,
        big: bool=False,
        pbar: bool=True
        ) -> Tuple[np.ndarray, float, float, float]:
    """
    Given a file generated by the executable used in call_num_frac parse that
    file into a usable form. This includes the hydrogen, helium, and
    metall mass fractions. And a list in the form of
    [('Element', massFrac, numberFrac),...]

    Parameters
    ----------
        file : BinaryIO
            file like object to abundance file
        big : bool
            single composition file or one file with many composition
        pbad : bool
            display progress bar

    Returns
    -------
        list
            list of the composition in the form [('Element',massFrac,numberFrac),...]
        float
            Hydrogen mass fraction
        float
            Helium mass fraction
        float
            Metal mass fraction
    """
    GN = r"\d+(?:\.\d+)?(?:[E|e][\+|-]\d+)?"
    CHEMSYM = r"[A-Z](?:[a-z])?(?:\s+)?=\s+"

    FRACP = re.compile(r"\n(?:\s+)?{a}{b}(?:\s+)?\+/-\s+{b}".format(a=CHEMSYM, b=GN))
    ZP = re.compile(r"sumZ\s+=\s+{a}".format(a=GN))
    ZXP = re.compile(r"Z/X\s+=\s+{a}".format(a=GN))

    COMPLDTYPE = np.dtype([("ChemSym", "<U11"), ('massFrac', 'f'),
                           ('numFrac', 'f'), ('ZmassFrac', 'f'),
                           ('massFracErr', 'f'), ('numFracErr', 'f'),
                           ('ZMassFracErr', 'f')])

    file.seek(0)
    contents = file.read().decode()
    nE = (contents.split('\n').index(" Mass fractions")
                 - contents.split('\n').index(" Number fractions")
                 - 1)
    # All extractions are done with regex. If There are multiple contents in
    #  the same file that is okay. Lines should be formaed like:
    # Metadata line (one per abundance)
    #  sumZ =  1.09103E-02+/- 8.112E-04    Z/X =  1.10307E-02+/- 8.201E-04
    # Mass/Number Fraction Line (one each per abundance per element)
    #  Cr =    0.00117221 +/-   0.00E+0.0
    fracs = re.findall(FRACP, contents)
    X = np.array([float(fracs[nE].split()[2])])
    sumZ_raw = re.findall(ZP, contents)

    gridDim = int(np.ceil(len(sumZ_raw)**(1/3)))

    Z = np.array([float(re.findall(f"{GN}", x)[0]) for x in sumZ_raw])
    Y = 1 - Z - X

    # Split the strings so that they are formated as three numbers
    #  seperated by spaces (remove = and +/-)
    # I have hard coded the positions of the different sections in the
    #  file for now
    # TODO: Programatically determine postion of sections of the file
    #       to that they are not hardcoded and can be more easily adapted
    rawNumFrac = list()
    rawMassFrac = list()
    rawZMassFrac = list()
    for i in tqdm(range(gridDim**3), disable=not pbar, desc="Extract Num/Mass/ZMass fracs from NumFrac file"):
        sIx = ((3*nE)-2)*i
        rawNumFrac.extend([re.sub(r'(?:=|\+\/-)', ' ', x) for x in fracs[sIx:sIx+nE]])
        rawMassFrac.extend([re.sub(r'(?:=|\+\/-)', ' ', x) for x in fracs[sIx+nE:sIx+(2*nE)]])
        rawZMassFrac.extend([re.sub(r'(?:=|\+\/-)', ' ', x) for x in fracs[sIx+(2*nE):sIx+(2*nE)+(nE-2)]])


    # Format these as (ElementSymbol, Value, ValueUncertantiy)
    numFrac = [(element.split()[0],
                float(element.split()[1]),
                float(element.split()[2]))
                for element in rawNumFrac]
    massFrac = [(element.split()[0],
                float(element.split()[1]),
                float(element.split()[2]))
                for element in rawMassFrac]
    ZMassFrac = [(element.split()[0],
                float(element.split()[1]),
                float(element.split()[2]))
                for element in rawZMassFrac]

    # These arrays need to be the same length
    #  so add H and He into the metal one so that 
    #  the length is the same
    for i in tqdm(range(gridDim**3), disable=not pbar, desc="Add H and He to ZMass Frac as 0"):
        ZMassFrac.insert((nE-2)*i, ('H', 0.00, 0.00))
        ZMassFrac.insert((nE-2)*i, ('He', 0.00, 0.00))

    compList = np.array([(x[0], x[1], y[1], z[1], x[2], y[2], z[2])
                for x, y, z in
                zip(massFrac, numFrac, ZMassFrac)],
                dtype=COMPLDTYPE)
    compList = compList.reshape(gridDim, gridDim, gridDim, nE)
    X = X.reshape(gridDim, gridDim, gridDim)
    Y = Y.reshape(gridDim, gridDim, gridDim)
    Z = Z.reshape(gridDim, gridDim, gridDim)

    if not big:
        return compList[0, 0, 0], X[0, 0, 0], Y[0, 0, 0], Z[0, 0, 0]
    else:
        return compList, X, Y, Z

def call_num_frac(
        abunTable : str,
        feh: Union[float, Tuple[float, float, int]],
        alpha:  Union[float, Tuple[float, float, int]],
        Y: Union[float, Tuple[float, float, int]],
        Xc : float,
        Yc : float,
        ) -> BinaryIO:
    """
    Given some grid of [Fe/H], [Alpha/Fe], and a(He) generate the number
    fractions files for every point on that grid. This is done using the
    libnumfrac shared library in ext/lib.

    Parameters
    ----------
        abunTable : string
            Table to parse abundances from.
        feh : float or tuple of floats
            [Fe/H] value to pass to program. If this is a float the numFrac
            program will only be evaluate at that point, if a tuple it will be
            evaluated at every point within linspace(feh[0], feh[1], feh[2]).
        alpha : float of tuple of floats
            [alpha/H] value to pass to program. If this is a float the numFrac
            program will only be evaluate at that point, if a tuple it will be
            evaluated at every point within linspace(alpha[0], alpha[1],
            alpha[2]).
        Y : float or tuple of floats
            a(He) value to pass to program. If this is a float the numFrac
            program will only be evaluate at that point, if a tuple it will be
            evaluated at every point within linspace(Y[0], Y[1], Y[2]).
        Xc : float
            Current X to use as a reference
        Yc : float
            Current Y to use as a referece (only used if Xc == 0)
    Returns
    -------
        fp : BinaryIO
            Temporary file object storing results
    """
    # De-emnhance all H out of the star if X = 0
    if Xc == 0:
        aH = -99.99
    else:
        aH = 12

    if not isinstance(feh, tuple):
        feh = (feh, feh, 1)
    if not isinstance(alpha, tuple):
        alpha = (alpha, alpha, 1)
    if not isinstance(Y, tuple):
        Y = (Y, Y, 1)

    fp = TemporaryFile()
    contents = numfrac.C_run(abunTable,
                             feh[0], feh[1], feh[2],
                             alpha[0], alpha[1], alpha[2],
                             Y[0], Y[1], Y[2],
                             False,
                             aH,
                             Xc,
                             Yc)
    fp.write(contents.encode('utf-8'))
    return fp

def get_base_composition(aTablePath : str) -> Tuple[list, float, float, float]:
    """
    For some abundance path return the "base" composition, this is mainly to be
    used for headers.

    Parameters
    ----------
        aTablePath : str
            Path to the abundance table in the form as described in the
            parseChemFile module documentation
    Returns
    -------
        list
            list of the composition in the form [('Element',massFrac,numberFrac),...]
        float
            Hydrogen mass fraction
        float
            Helium mass fraction
        float
            Metal mass fraction
    """
    aTable = open_and_parse(aTablePath)
    Xc = aTable['AbundanceRatio']['X']
    Yc = aTable['AbundanceRatio']['Y']
    aHe = aTable['RelativeAbundance']['He']['a']

    fp = call_num_frac(aTablePath, 0.0, 0.0, aHe, Xc, Yc)
    compList, X, Y, Z = parse_numfrac_file(fp, pbar=False)
    fp.close()
    return compList, X, Y, Z
